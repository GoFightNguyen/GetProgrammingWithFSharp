# Lesson 25 Consuming C# from F#
## 25.1 Referencing C# code in F#
Virtually all C# code can be consumed by F#, including:
- all BCL code
- .NET assemblies including NuGet packages
- Sibling projects in the same solution

## 25.2 The Visual Studio Experience
### 25.2.1 Debugging
You can debug an application that works across both languages.
The call stack is preserved across the two languages.

### 25.2.2 Navigating across Projects
Tools such as Rename, Find All References, and Go To Definition do not work across languages.
For example, if you use Go To Definition on a C# class from F#, you'll instead be taken to the F# metadata view of the C# class.

### 25.2.3 Projects and Assemblies
If you make changes to the C# project, you must explicitly build that project before you can "see" the changes in F#.

### 25.2.4 Referencing assemblies in scripts
F# provides a few useful directives for referencing assemblies within F# scripts
| Directive | Description | Example |
| --- | --- | --- |
| #r | references a DLL | #r @"C:\source\app.dll" |
| #I | adds a path to the #r search path | #I @"c:\source\" |
| #load | loads and executes an F# .fsx or .fs file | #load @"c:\source\code.fsx" |

## 25.3 Working with OO constructs
F# considers constructors to be a function, therefore you can use them as you would any function.
```csharp
public class Person
{
    public Person(string name) => Name = name;
    public void PrintName() => Console.WriteLine($"My name is {Name}");
}
```
```fsharp
let paul = Person "Paul"
let longhand =
    [ "Tony"; "Fred"; "Sammy" ]
    |> List.map(fun name -> Person(name))
let shorthand =
    [ "Tony"; "Fred"; "Sammy" ]
    |> List.map Person
```

### 25.3.1 Working with interfaces
Interfaces can be useful in F#, particularly when working with pluggable pieces of code needing to change at runtime.
F# has good support for implementing them, both at the language and at the tooling level.

```fsharp
open System.Collections.Generic

type PersonComparer() =
    interface IComparer<Person> with
        member this.Compare(x,y) = x.Name.CompareTo(y.Name)

let pComparer = PersonComparer() :> IComparer<Person>
pComparer.Compare(Person "Simon", Person "Fred")
```

Notes:
- The `Compare` function does not need type annotations for `x` and `y` because it is inferred by the generic type argument `<Person>`.
- you must explicitly upcast from `PersonComparer` to `IComparer<Person>` by using the `:>` operator
  - F# implements interfaces explicitly

### 25.3.2 Object expressions
_Object Expressions_ allow you to create an instance of an interface without creating an intermediary type.

```fsharp
let pComparer =
    { new IComparer<Person> with
        member this.Compare(x,y) = x.Name.CompareTo(y.Name) }
```

The type of `pComparer` here is `IComparer<Person>`.
Its "real" name is generated by the compiler and hidden.

Object expressions allow creation of an implementation of the interface as an object in one step!

### 25.3.3 Nulls, nullables, and options
C# classes and structs don't work natively with options.
The F# `Option` module provides some combinators allowing you to jump between F# options and classes, which are always potentially null, and structs that are wrapped as nullables.

```fsharp
open System
let blank:string = null
let name = "Vera"
let number = Nullable 10
let blankAsOption = blank |> Option.ofObj // null maps to None
let nameAsOption = name |> Option.ofObj // non-null maps to Some
let numberAsOption = number |> Option.ofNullable
let unsafeName = Some "Fred" |> Option.toObj // options can be mapped back to classes or Nullable types
```